Note: Despite the naming conventions used, I do not believe this  type system to be an ECS 
implemtation, rather, I simply borrow the ECS naming conventions to express my own ideas.

/****************************
    Type System Overview 
*****************************/
I've developed a Dynamic Type system that doesn't rely on inheritence and OOP, but rather, is based
on the ideas of composition and aggregation.This was done in order to avoid being boxed into a messy inheritence
hierearchy.

The main idea of my system is simple: The systems state is composed of 
"entities" which are,in turn,composed of "components". Every "component" has a unique id and holds
a little bit of an "entities" state. The components are then 'chained' together into a list to form 
an entity. Factories are responsible creating instances of entities and for chaining the entities 
together. 

In my system, entities are just lists of relative offsets(not pointers) into a component table.
Components, are stored in the SystemState struct. Each Component Instance is stored in a Vec<ComponentType>.
These Component Vectors are then aliased into a table for dynamic access. Dynamic Access involves using 
a data structure implementing the SystemPointer trait.For example suppose we have three components types that 
implement SystemComponent<..>: 
-Transform 
-Render
-Physics

To help try and get the main idea, a pseudo-example of implementing SystemState and components, 
could look something like this (pseudo-code is C/C++ mixed w/ rust):
-----------------------------------------PSEUDO CODE STARTS HERE---------------------------------------
struct Transform{
    Matrix3x3 rot;
    Vec3 scale;
    Vec3 translate; 
}

struct Render{
    SystemPointer transform_comp;//points to a transform component
    ModelData data;
    ShaderProgram prog; 
}

struct Physics{
    SystemPointer transoform_comp;//points to transform component
    Vec velocity;
    Vec acceleration:
    float mass:
    AABB bounds; 
}

struct ExampleState{
    ... 
    GUIWindowFactory  window_fact;
    GUIButtonFactory  button_fact;
    GUISliderFactory  slider_fact;
    ...
    Vec<Transform> transform_comps;
    Vec<Render> render_comps:
    Vec<Physics> physics_comps; 
    ...
    Vec<(int,void*)> component_table; //for arbitrary access 
    ...

}

const int render_comp_list = 0; 
const int physics_comp_list= 1; 
const int transofmr_comp_list=2;

void init_table(ExampleState & state){
    //components can be accessed with an integer touple (i,j) by building a 'component_table'.
    //Note:
    //1) row index clearly  associated with the component list type.
    //2) Because of (1) we know rows indexes (i) need less bits than column indexes (j) because we can expect there to be 
    //   more component instances than component types.
    
    state.component_table = vec![
        (render_comp_list, &render_comps),
        (physics_comp_list,&physics_comps),
        (transform_comp_list&transform_comps),
    ];
}
-----------------------------------------PSEUDO CODE ENDS HERE---------------------------------------

So as you can see,all the component data is actually in nice contigious chunks. 
For 'non-dynamic' iterations we will iterate over the specitic component vectors rather than 
the generic 'component_table'. For 'dynamic' iterations,which we can expect to be much slower, we can iterate 
over entities using the component_table as a lookup table. 



This explanation is obviosly incomplete, doesn't cover deleting/creating operations or how factories work.
This doc badly  needs editing,but im done with writing this crap for now.  





/**********************
SystemPointer Explanation
***********************/


SystemPointer is a n-bit pointer that holds 3 seperate values:
-the row index, which specifies the component list 
-the column index, which specifies the specific component instance in the list (specified in the row) 
-the component id, each component has a unique id which can be used to check if the queried component is 
actually the one we are looking for. 

In code there is currently an implementation for SystemPointer called GamePointer, from now on well be talking about
that implementation.

The binary format for the GamePointer is as followed:
where
    'p' is the component/entity id bits
    'c' is the column index bits
    'r' is the row index bits

This figue clearly outlines the format:
+--------------------------------------------------------------------------------------------------------------------+
|31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16  15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0|
| p   p  p   p   p    p   p  p   p   p   p   p    p   p   p  p   c   c   c   c   c   c   c  c  c  c  r  r  r  r  r  r|
+--------------------------------------------------------------------------------------------------------------------+

Note:This format could change depending on how SystemPointer is implemented.
Most SystemPointer data formats are likely to be similar to the one described here for three main reasons:
->SystemPointers should be as compact as possible to reduce cache pollution.
->Not as many bits are needed to represent the row index, as the row index
 represents the component type of a component list. 
->SystemPointers need to include the component's unique id in order to validate table lookups
